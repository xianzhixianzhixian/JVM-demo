# 可达性分析算法
1、在可达性分析中被判定为不可达的对象，也不是一定要被回收的；一个对象真正要被回收时至少要经历两次标记过程，如果对象
在进行可达性分析后发现没有与GCRoots相连的引用链，那它将会被第一次标记；随后会进行一次筛选，判段条件是此对象是否有必
要执行finalize()方法；如果对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情
况都视为没有必要执行

2、如果一个对象被判定为有必要执行finalize()方法，该对象会被防止在一个名为F-Queue的队列之中，并在稍后由一条虚拟机
自动建立的低优先级的Finalizer线程去执行它们的finalize()方法；“执行”的意思是虚拟机会触发这个方法开始运行，但并不
保证一定会等待该方法运行结束；因为finalize)_方法执行缓慢或发生了死循环，很可能会导致F-Queue队列中的其它对象处于永久
等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱被回收的最后一次机会，稍后收集器将对F-Queue中的对象
进行第二次小规模的标记，只要对象重新与引用链上的任何一个对象建立关联即可，那么对象将被移出即将回收的集合；如果对象这
时候还未关联上GCRoots上的任何一个对象，那改对象基本上就要被回收了

3、finalize()方法会在对象被回收前调用，一个对象的finalize()方法只会被调用一次，如果对象面临下一次回收它的finalize()
方法也不会被执行

# 执行结果分析
[GC (System.gc())  2621K->448K(251392K), 0.0168759 secs]
[Full GC (System.gc())  448K->418K(251392K), 0.0092790 secs]
finalize method executed！
alive
[GC (System.gc())  3040K->450K(251392K), 0.0024586 secs]
[Full GC (System.gc())  450K->408K(251392K), 0.0124096 secs]
SAVE_HOOK revoveried

第一次执行对象在finalize()方法中管连上了GCRoots引用链中的对象（把自己this赋值给某个类变量或者对象的成员变量）所以
没有被回收，而一个对象的finalize()方法只会被调用一次，所以第二次GC的时候该对象被回收了